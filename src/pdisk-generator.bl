//************************************************************************************************
// pdisk-generator
//
// File:   pdisk-generator.bl 
// Author: Martin Dorazil
// Date:   3/18/19
//
//************************************************************************************************

#load "std/core.bl"
#load "std/math.bl"
#load "vec2_arr.bl"

GridSize      :: 1.f;   // Size of the generated area
TryLimit      :: 100;   // Maximum try count for point placement
MinDistance   :: 0.03f; // Minimum distance between points
Seed          :: 666;   // Random seed
CsHeader      :: "// Source generated by pdisk-generator tool.\n//  Generated: % points\n\nusing UnityEngine;\n\nnamespace StoraEnso {\npublic static class PoissonDisk\n{\n";
CsFooter      :: "\n    };\n}\n}\n";
CsVector      :: "new Vector2(%f, %f), ";
CsMinDistance :: "    public const float MinDistance = %f;\n\n";
CsPoints      :: "    public static Vector2[] Points =\n    {\n";
CellSize      :: MinDistance / 1.414213562f;
CellPerDim    :: cast(s32) (GridSize / CellSize) + 1;
TotalCells    :: CellPerDim * CellPerDim;
PI2           :: cast(f32)PI * 2.f;

main :: fn () s32 {
  srand(Seed);

  grid := {:[TotalCells]*Vec2: 0 };
  grid_slice := {:[]*Vec2: grid.len, grid.ptr};
  points : Vec2Arr;
  active : Vec2Arr;

  vec2_arr_init(&points, 1024);
  vec2_arr_init(&active, 1024);

  grid_p : iVec2;

  // initialial point
  {
    init_p : Vec2;

    rand_vec2(&init_p);
    grid_i := point_to_id(&init_p, &grid_p);
    grid[grid_i] = vec2_arr_push_back(&points, &init_p);
    vec2_arr_push_back(&active, &init_p);
  }

  loop active.data.len > 0 {
    tried := 0;
    active_i := rand() % active.data.len;
    active_p := active.data[active_i];

    loop tried < TryLimit {
      alpha := rand_range(0.f, PI2);
      d := rand_range(MinDistance, 2.f * MinDistance);

      new_p : Vec2;
      new_p.x = active_p.x + cosf(alpha) * d;
      new_p.y = active_p.y + sinf(alpha) * d;

      new_i := point_to_id(&new_p, &grid_p);
      if is_point_in_grid(&new_p) && grid[new_i] == null && can_use(grid_slice, &new_p, &grid_p) {
	grid[new_i] = vec2_arr_push_back(&points, &new_p);
	vec2_arr_push_back(&active, &new_p);
	break;
      }

      tried += 1;
      if tried == TryLimit {
        vec2_arr_remove(&active, active_i);
      }
    }
  }

  // Export as C# class.
  print(CsHeader, points.data.len);
  print_floats(CsMinDistance, cast(f64) MinDistance);
  print(CsPoints);

  loop i := 0; i < points.data.len; i += 1 {
    p := points.data[i];
    x := cast(f64) p.x;
    y := cast(f64) p.y;
    print_floats(CsVector, x, y);
  }

  print(CsFooter);

  vec2_arr_terminate(&points);
  vec2_arr_terminate(&active);
  return 0;
};

rand_vec2 :: fn (out: *Vec2) {
  if out == null { abort(); }
  out.x = rand_range(0.f, 1.f);
  out.y = rand_range(0.f, 1.f);
};

rand_range :: fn (from: f32, to: f32) f32 {
  frand := cast(f64) rand();
  r := cast(f32)(frand / cast(f64) RAND_MAX);
  return lerp(from, to, r);
};

grid_point_to_id :: fn (p: *iVec2) s32 {
  return CellPerDim * p.x + p.y;
};

point_to_id :: fn (p: *Vec2, out_grid_pos: *iVec2) s32 {
  out_grid_pos.x = cast(s32)(floorf(p.x / CellSize));
  out_grid_pos.y = cast(s32)(floorf(p.y / CellSize));
  return grid_point_to_id(out_grid_pos);
};

is_point_in_grid :: fn (p: *Vec2) bool {
  return p.x > MinDistance && p.y > MinDistance && p.x < GridSize && p.y < GridSize;
};

distance :: fn (a: *Vec2, b: *Vec2) f32 {
  return sqrtf(powf(b.x - a.x, 2.f) + powf(b.y - a.y, 2.f));
};

can_use :: fn (grid: []*Vec2, p: *Vec2, grid_p: *iVec2) bool {
  nx := {:[8]s32: -1,  0,  1,  1,  1,  0, -1, -1};
  ny := {:[8]s32:  1,  1,  1,  0, -1, -1, -1,  0};

  loop i := 0; i < nx.len; i += 1 {
    n := fn (grid: []*Vec2, grid_x: s32, grid_y: s32) *Vec2 {
      gp := {:iVec2: grid_x, grid_y};
      i := grid_point_to_id(&gp); 

      if i >= 0 && i < grid.len {
        return grid[i];
      }

      return null;
    } (grid, grid_p.x + nx[i], grid_p.y + ny[i]);

    if n != null && distance(n, p) < MinDistance { return false; }
  }

  return true;
};

